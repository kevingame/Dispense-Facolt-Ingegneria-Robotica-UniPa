<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relazione Progetto Tris Robotico</title>
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        
        body {
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.6;
            color: #000;
            margin: 0;
            padding: 2cm;
            max-width: 21cm;
            margin: auto;
            background: white;
        }
        
        .page-break {
            page-break-before: always;
            margin-top: 2cm;
        }
        
        .title-page {
            text-align: center;
            margin-top: 4cm;
        }
        
        .title-page h1 {
            font-size: 18pt;
            margin-bottom: 0.5cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .title-page h2 {
            font-size: 16pt;
            margin-bottom: 2cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .title-page .project-title {
            font-size: 24pt;
            margin: 3cm 0;
            color: #000080;
            font-weight: bold;
        }
        
        .info-box {
            text-align: left;
            margin: 2cm auto;
            width: 70%;
            font-size: 12pt;
            line-height: 2;
        }
        
        .info-box strong {
            display: inline-block;
            width: 180px;
        }
        
        .toc {
            margin-top: 2cm;
        }
        
        .toc h2 {
            text-align: center;
            font-size: 18pt;
            margin-bottom: 1.5cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .toc-item {
            margin-bottom: 0.15cm;
            display: flex;
            justify-content: space-between;
            font-size: 12pt;
    		padding: 0.05cm 0;
    		line-height: 1.05;
        }
        
        .toc-item.main {
            font-weight: bold;
            margin-top: 0.3cm;
        }
        
        .toc-item.sub {
            margin-left: 0.8cm;
            font-weight: normal;
        }
        
        .toc-item span:first-child {
            flex-grow: 1;
        }
        
        .toc-item span:last-child {
            margin-left: 1cm;
        }
        
        .chapter {
            margin-top: 1.5cm;
        }
        
        .chapter h2 {
            font-size: 16pt;
            color: #000080;
            border-bottom: 2px solid #000080;
            padding-bottom: 0.3cm;
            margin-bottom: 0.8cm;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .chapter h3 {
            font-size: 14pt;
            color: #000060;
            margin-top: 1cm;
            margin-bottom: 0.5cm;
            font-weight: bold;
        }
        
        .chapter h4 {
            font-size: 12pt;
            color: #000040;
            margin-top: 0.8cm;
            margin-bottom: 0.4cm;
            font-weight: bold;
        }
        
        .theory {
            background-color: #f0f8ff;
            padding: 0.6cm;
            border-left: 4px solid #4169e1;
            margin: 0.8cm 0;
        }
        
        .code-block {
            background-color: #f5f5f5;
            padding: 0.5cm;
            border: 1px solid #ddd;
            margin: 0.8cm 0;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .note {
            background-color: #fffacd;
            padding: 0.6cm;
            border: 2px solid #daa520;
            margin: 0.8cm 0;
        }
        
        .highlight {
            background-color: #fff8dc;
            padding: 0.6cm;
            border-left: 4px solid #ffa500;
            margin: 0.8cm 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1cm 0;
            font-size: 11pt;
        }
        
        th, td {
            border: 1px solid #333;
            padding: 0.4cm;
            text-align: left;
        }
        
        th {
            background-color: #4169e1;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        ul, ol {
            margin: 0.5cm 0;
            padding-left: 1.5cm;
        }
        
        li {
            margin-bottom: 0.3cm;
        }
        
        .formula {
            text-align: center;
            margin: 0.8cm 0;
            font-size: 13pt;
            font-style: italic;
        }
        
        p {
            text-align: justify;
            margin-bottom: 0.5cm;
        }
        
        @media print {
            body {
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>

    <!-- PAGINA DEL TITOLO -->
    <div class="title-page">
        <h1>Universit√† degli Studi di Palermo</h1>
        <h2>Facolt√† di Ingegneria</h2>
        
        <div class="project-title">
            Progetto Esame<br>Sistemi Robotici
        </div>
        
        <div class="info-box">
            <div><strong>Sviluppatori:</strong> Petrone Kevin, Di Peri Marta, Baragona Daniele</div>
            <div><strong>Matricola:</strong> 0774409, 0774023, 0769515</div>
            <div style="margin-top: 0.8cm;"><strong>Docente:</strong> Prof. Filippo D'Ippolito</div>
            <div><strong>Corso:</strong> Ingegneria Robotica</div>
            <div><strong>Anno Accademico:</strong> 2025/2026</div>
            <div><strong>Data:</strong> Dicembre 2025</div>
        </div>
    </div>

<!-- INDICE -->
<div class="page-break">
    <div class="toc">
        <h2>Indice</h2>
        
        <div class="toc-item main">
            <span>1. INTRODUZIONE</span>
        </div>
        <div class="toc-item sub">
            <span>1.1 Obiettivi del Progetto</span>
        </div>
        <div class="toc-item sub">
            <span>1.2 Specifiche Tecniche</span>
        </div>
        
        <div class="toc-item main">
            <span>2. ARCHITETTURA DEL SISTEMA</span>
        </div>
        <div class="toc-item sub">
            <span>2.1 Hardware Utilizzato</span>
        </div>
        <div class="toc-item sub">
            <span>2.2 Software e Librerie</span>
        </div>
        <div class="toc-item sub">
            <span>2.3 Schema di Comunicazione</span>
        </div>
        
        <div class="toc-item main">
            <span>3. MODELLO CINEMATICO</span>
        </div>
        <div class="toc-item sub">
            <span>3.1 Cinematica Diretta</span>
        </div>
        <div class="toc-item sub">
            <span>3.2 Cinematica Inversa</span>
        </div>
        <div class="toc-item sub">
            <span>3.3 Workspace del Robot</span>
        </div>
        <div class="toc-item sub">
            <span>3.4 Cinematica Differenziale</span>
        </div>
        
        <div class="toc-item main">
            <span>4. COMUNICAZIONE E INTEGRAZIONE</span>
        </div>
        <div class="toc-item sub">
            <span>4.1 Protocollo di Comunicazione Seriale</span>
        </div>
        <div class="toc-item sub">
            <span>4.2 Gestione Interpolazione Hardware</span>
        </div>
        
        <div class="toc-item main">
            <span>5. PIANIFICAZIONE DEL MOTO</span>
        </div>
        <div class="toc-item sub">
            <span>5.1 Traiettorie Lineari</span>
        </div>
        <div class="toc-item sub">
            <span>5.2 Generazione Simboli X e O</span>
        </div>
        <div class="toc-item sub">
            <span>5.3 Coordinamento Movimenti Penna</span>
        </div>
        
        <div class="toc-item main">
            <span>6. SIMULAZIONE CON ROBOTICS TOOLBOX</span>
        </div>
        <div class="toc-item sub">
            <span>6.1 Modellazione del Robot</span>
        </div>
        <div class="toc-item sub">
            <span>6.2 Visualizzazione 3D e Video</span>
        </div>
        
        <div class="toc-item main">
            <span>7. LOGICA DI GIOCO E ALGORITMO AI</span>
        </div>
        <div class="toc-item sub">
            <span>7.1 Rappresentazione dello Stato</span>
        </div>
        <div class="toc-item sub">
            <span>7.2 Algoritmo Euristico Minimax</span>
        </div>
        
        <div class="toc-item main">
            <span>8. TESTING E VALIDAZIONE</span>
        </div>
        <div class="toc-item sub">
            <span>8.1 Verifica Cinematica</span>
        </div>
        
        <div class="toc-item main">
            <span>9. CONCLUSIONI</span>
        </div>
        <div class="toc-item sub">
            <span>9.1 Risultati Ottenuti</span>
        </div>
        
        <!-- APPENDICE -->
        <div class="toc-item main">
            <span>APPENDICE A ‚Äì GUIDA ALL'INSTALLAZIONE E CONFIGURAZIONE</span>
        </div>
        <div class="toc-item sub">
            <span>A.1 Requisiti di Sistema</span>
        </div>
        <div class="toc-item sub">
            <span>A.2 Installazione Arduino IDE</span>
        </div>
        <div class="toc-item sub">
            <span>A.3 Installazione MATLAB R2024b</span>
        </div>
        <div class="toc-item sub">
            <span>A.4 Installazione Robotics Toolbox</span>
        </div>
        <div class="toc-item sub">
            <span>A.5 Configurazione File Progetto</span>
        </div>
        <div class="toc-item sub">
            <span>A.6 Caricamento Codice Arduino</span>
        </div>
        <div class="toc-item sub">
            <span>A.7 Esecuzione Sistema</span>
        </div>
        <div class="toc-item sub">
            <span>A.8 Risoluzione Problemi Comuni</span>
        </div>
        <div class="toc-item sub">
            <span>A.9 Personalizzazione Parametri</span>
        </div>
    </div>
</div>

    <!-- CAPITOLO 1: INTRODUZIONE -->
    <div class="page-break">
        <div class="chapter">
            <h2>1. Introduzione</h2>
            
            <h3>1.1 Obiettivi del Progetto</h3>
            
            <p>Il presente progetto si inserisce nell'ambito dei sistemi robotici interattivi e ha come obiettivo la realizzazione di un robot antropomorfo a 3 gradi di libert√† capace di giocare autonomamente al gioco del tris contro un utente umano. Il sistema integra componenti hardware (Arduino, servomotori, display OLED, buzzer) con un ambiente di simulazione e controllo realizzato in MATLAB utilizzando la Robotics Toolbox.</p>
            
            <div class="highlight">
                <strong>Obiettivi principali:</strong>
                <ul>
                    <li><strong>Progettazione cinematica:</strong> Sviluppo del modello cinematico diretto e inverso per un manipolatore planare 2R + prismatico</li>
                    <li><strong>Controllo in tempo reale:</strong> Implementazione di un sistema di controllo Arduino per la gestione coordinata di tre servomotori con interpolazione fluida dei movimenti</li>
                    <li><strong>Intelligenza Artificiale:</strong> Sviluppo di un algoritmo di gioco basato su logica euristica per garantire mosse competitive</li>
                    <li><strong>Interfaccia utente:</strong> Integrazione di feedback visivo (OLED) e sonoro (buzzer) per migliorare l'esperienza interattiva</li>
                    <li><strong>Simulazione e validazione:</strong> Utilizzo di MATLAB per simulare, validare e registrare l'intero processo di gioco</li>
                </ul>
            </div>

			<div style="text-align: center; margin-top: 20px;">
        		<img src="./XbOt/sistemi_robotici.jpg" alt="Scansione dell&#39;aula" style="max-width: 90%; height: auto; border: 1px solid #ccc; border-radius: 8px;">
    		</div>
			
            <p>Il progetto rappresenta un esempio concreto di integrazione tra teoria della robotica (cinematica, pianificazione del moto) e applicazione pratica, dimostrando come concetti matematici complessi possano essere tradotti in un sistema funzionante e interattivo.</p>
            
            <h3>1.2 Specifiche Tecniche</h3>
            
            <p>Il robot realizzato presenta le seguenti caratteristiche tecniche:</p>
            
            <table>
                <tr>
                    <th>Componente</th>
                    <th>Specifica</th>
                    <th>Valore/Modello</th>
                </tr>
                <tr>
                    <td>Microcontrollore</td>
                    <td>Arduino Uno</td>
                    <td>ATmega328P</td>
                </tr>
                <tr>
                    <td>Servomotore 1 (base)</td>
                    <td>Rotazione base</td>
                    <td>0¬∞ - 180¬∞, Pin 9</td>
                </tr>
                <tr>
                    <td>Servomotore 2 (braccio)</td>
                    <td>Rotazione braccio</td>
                    <td>0¬∞ - 180¬∞, Pin 10</td>
                </tr>
                <tr>
                    <td>Servomotore 3 (penna)</td>
                    <td>Alzata/abbassata penna</td>
                    <td>90¬∞ - 180¬∞, Pin 11</td>
                </tr>
                <tr>
                    <td>Display</td>
                    <td>OLED SSD1306</td>
                    <td>128x64 pixel, I2C</td>
                </tr>
                <tr>
                    <td>Audio</td>
                    <td>Buzzer piezoelettrico</td>
                    <td>Pin 3</td>
                </tr>
                <tr>
                    <td>Comunicazione</td>
                    <td>Seriale</td>
                    <td>115200 baud</td>
                </tr>
                <tr>
                    <td>Lunghezza link 1</td>
                    <td>L‚ÇÅ</td>
                    <td>2.5 unit√†</td>
                </tr>
                <tr>
                    <td>Lunghezza link 2</td>
                    <td>L‚ÇÇ</td>
                    <td>2.0 unit√†</td>
                </tr>
                <tr>
                    <td>Workspace</td>
                    <td>Piano XY</td>
                    <td>[-1, 5] √ó [-3, 5]</td>
                </tr>
                <tr>
                    <td>Griglia tris</td>
                    <td>Dimensione cella</td>
                    <td>0.9 √ó 0.9 unit√†</td>
                </tr>
                <tr>
                    <td>Tempo interpolazione</td>
                    <td>Movimento fluido</td>
                    <td>500 ms</td>
                </tr>
            </table>
            
            <div class="note">
                <strong>Nota:</strong> Il sistema √® progettato per operare su un piano di lavoro orizzontale. Le coordinate sono espresse in unit√† adimensionali proporzionali alle lunghezze fisiche dei link del robot.
            </div>
        </div>
    </div>

    <!-- CAPITOLO 2: ARCHITETTURA DEL SISTEMA -->
    <div class="page-break">
        <div class="chapter">
            <h2>2. Architettura del Sistema</h2>
            
            <h3>2.1 Hardware Utilizzato</h3>
            
            <p>L'architettura hardware del sistema √® composta da diversi moduli interconnessi che collaborano per realizzare le funzionalit√† del robot:</p>
            
            <h4>2.1.1 Sistema di Attuazione</h4>
            
            <div class="theory">
                <strong>Servomotori:</strong>
                <ul>
                    <li><strong>Servo 1 (Base):</strong> Montato sul pin 9, controlla la rotazione alla base del robot. Riceve comandi in gradi da 0¬∞ a 180¬∞ e posiziona il primo link del manipolatore.</li>
                    <li><strong>Servo 2 (Braccio):</strong> Montato sul pin 10, controlla l'angolo del secondo link. Opera in modalit√† invertita (180¬∞ - angolo calcolato) per compensare l'orientamento meccanico.</li>
                    <li><strong>Servo 3 (Penna):</strong> Montato sul pin 11, gestisce l'alzata e l'abbassata della penna tramite un giunto prismatico simulato. Range operativo: 90¬∞ (penna su) - 180¬∞ (penna gi√π).</li>
                </ul>
            </div>
            
            <h4>2.1.2 Sistema di Interfaccia</h4>
            
            <p><strong>Display OLED SSD1306:</strong> Display grafico da 128√ó64 pixel con comunicazione I2C (indirizzo 0x3C). Utilizzato per visualizzare:</p>
            <ul>
                <li>Logo del sistema all'avvio ("XBOT v1.0")</li>
                <li>Messaggi di stato durante il gioco</li>
                <li>Indicazioni del turno corrente</li>
                <li>Messaggi di vittoria/sconfitta/pareggio con animazioni di scorrimento</li>
            </ul>
            
            <p><strong>Buzzer Piezoelettrico:</strong> Connesso al pin 3, genera feedback sonoro per eventi di gioco:</p>
            <ul>
                <li>Melodia di avvio (4 note crescenti)</li>
                <li>Suono per ogni cambio turno</li>
                <li>Melodia di vittoria (7 note festose)</li>
                <li>Melodia game over (4 note discendenti)</li>
            </ul>
            
            <h4>2.1.3 Schema Elettrico</h4>
            
            <div class="code-block">Arduino Uno
    ‚îÇ
    ‚îú‚îÄ Pin 9  ‚Üí Servo 1 (Base)
    ‚îú‚îÄ Pin 10 ‚Üí Servo 2 (Braccio)
    ‚îú‚îÄ Pin 11 ‚Üí Servo 3 (Penna)
    ‚îú‚îÄ Pin 3  ‚Üí Buzzer
    ‚îú‚îÄ SDA    ‚Üí OLED SDA (Display I2C)
    ‚îú‚îÄ SCL    ‚Üí OLED SCL (Display I2C)
    ‚îî‚îÄ USB    ‚Üí Comunicazione Seriale con MATLAB</div>
            
            <h3>2.2 Software e Librerie</h3>
            
            <h4>2.2.1 Ambiente Arduino</h4>
            
            <p>Il firmware Arduino √® implementato utilizzando le seguenti librerie:</p>
            
            <table>
                <tr>
                    <th>Libreria</th>
                    <th>Versione</th>
                    <th>Funzione</th>
                </tr>
                <tr>
                    <td>Servo.h</td>
                    <td>Standard</td>
                    <td>Controllo servomotori tramite segnale PWM</td>
                </tr>
                <tr>
                    <td>Wire.h</td>
                    <td>Standard</td>
                    <td>Comunicazione I2C per display OLED</td>
                </tr>
                <tr>
                    <td>Adafruit_GFX.h</td>
                    <td>1.x</td>
                    <td>Libreria grafica di base per display</td>
                </tr>
                <tr>
                    <td>Adafruit_SSD1306.h</td>
                    <td>2.x</td>
                    <td>Driver specifico per display SSD1306</td>
                </tr>
            </table>
            
            <h4>2.2.2 Ambiente MATLAB</h4>
            
            <p>Il sistema di controllo e simulazione utilizza:</p>
            
            <table>
                <tr>
                    <th>Toolbox/Funzione</th>
                    <th>Utilizzo</th>
                </tr>
                <tr>
                    <td>Robotics Toolbox</td>
                    <td>Modellazione cinematica, simulazione 3D del robot</td>
                </tr>
                <tr>
                    <td>SerialPort</td>
                    <td>Comunicazione bidirezionale con Arduino</td>
                </tr>
                <tr>
                    <td>VideoWriter</td>
                    <td>Registrazione video della simulazione</td>
                </tr>
                <tr>
                    <td>Link/SerialLink</td>
                    <td>Definizione della struttura cinematica del robot</td>
                </tr>
            </table>
            
            <div class="highlight">
                <strong>Flusso di lavoro software:</strong>
                <ol>
                    <li>MATLAB inizializza la connessione seriale con Arduino (115200 baud)</li>
                    <li>Arduino entra in modalit√† ascolto e inizializza i servomotori</li>
                    <li>MATLAB simula il robot e calcola la cinematica inversa per ogni posizione target</li>
                    <li>I comandi vengono inviati ad Arduino nel formato: <code>A,angolo1,angolo2,angolo3</code></li>
                    <li>Arduino interpola i movimenti in modo fluido e aggiorna i servomotori</li>
                    <li>Il feedback viene visualizzato sul display OLED e tramite suoni</li>
                    <li>MATLAB registra ogni frame della simulazione per generare il video finale</li>
                </ol>
            </div>
            
            <h3>2.3 Schema di Comunicazione</h3>
            
            <p>Il protocollo di comunicazione seriale tra MATLAB e Arduino √® basato su messaggi testuali terminati dal carattere newline (\n). I comandi supportati sono:</p>
            
            <table>
                <tr>
                    <th>Comando</th>
                    <th>Formato</th>
                    <th>Esempio</th>
                    <th>Descrizione</th>
                </tr>
                <tr>
                    <td>Posizione</td>
                    <td>A,Œ∏‚ÇÅ,Œ∏‚ÇÇ,z</td>
                    <td>A,90,120,180</td>
                    <td>Imposta angoli servomotori (gradi)</td>
                </tr>
                <tr>
                    <td>Suono mossa</td>
                    <td>MOVE</td>
                    <td>MOVE</td>
                    <td>Riproduce suono cambio turno</td>
                </tr>
                <tr>
                    <td>Vittoria</td>
                    <td>WIN</td>
                    <td>WIN</td>
                    <td>Riproduce melodia di vittoria</td>
                </tr>
                <tr>
                    <td>Sconfitta</td>
                    <td>LOSE</td>
                    <td>LOSE</td>
                    <td>Riproduce melodia game over</td>
                </tr>
                <tr>
                    <td>Messaggio</td>
                    <td>MSG,testo,x,y,size</td>
                    <td>MSG,Turno,0,25,2</td>
                    <td>Visualizza testo su display OLED</td>
                </tr>
            </table>
            
            <div class="note">
                <strong>Timing critico:</strong> Arduino implementa un sistema di interpolazione non bloccante che consente di ricevere nuovi comandi durante l'esecuzione di un movimento. Questo garantisce fluidit√† e reattivit√† del sistema senza accumulo di ritardi.
            </div>
        </div>
		
		<div style="text-align: center; margin-top: 20px;">
			<img src="./XbOt/matlab.jpg" alt="Scansione dell&#39;aula" style="max-width: 90%; height: auto; border: 1px solid #ccc; border-radius: 8px;">
		</div>
    </div>

    <!-- CAPITOLO 3: MODELLO CINEMATICO -->
    <div class="page-break">
        <div class="chapter">
            <h2>3. Modello Cinematico</h2>
            
            <h3>3.1 Cinematica Diretta</h3>
            
            <p>Il robot √® modellato come una catena cinematica seriale composta da tre link secondo i parametri di Denavit-Hartenberg:</p>
            
            <table>
                <tr>
                    <th>Link</th>
                    <th>a·µ¢</th>
                    <th>Œ±·µ¢</th>
                    <th>d·µ¢</th>
                    <th>Œ∏·µ¢</th>
                    <th>Tipo</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>L‚ÇÅ</td>
                    <td>0</td>
                    <td>0</td>
                    <td>Œ∏‚ÇÅ (var)</td>
                    <td>Rotoidale</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>L‚ÇÇ</td>
                    <td>0</td>
                    <td>0</td>
                    <td>Œ∏‚ÇÇ (var)</td>
                    <td>Rotoidale</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>0</td>
                    <td>œÄ/2</td>
                    <td>d‚ÇÉ</td>
                    <td>0</td>
                    <td>Prismatico</td>
                </tr>
            </table>
            
            <div class="theory">
                <strong>Equazioni della cinematica diretta (piano XY):</strong>
                <p>Per i primi due link (manipolatore planare 2R):</p>
                <div class="formula">
                    x = L‚ÇÅ cos(Œ∏‚ÇÅ) + L‚ÇÇ cos(Œ∏‚ÇÅ + Œ∏‚ÇÇ)
                </div>
                <div class="formula">
                    y = L‚ÇÅ sin(Œ∏‚ÇÅ) + L‚ÇÇ sin(Œ∏‚ÇÅ + Œ∏‚ÇÇ)
                </div>
                <p>Il terzo giunto prismatico controlla la coordinata z (alzata della penna) nel range [0.05, 0.8].</p>
            </div>
            
            <p>In MATLAB, la struttura del robot √® definita mediante:</p>
            
            <div class="code-block">L1 = Link('d',0,'a',2.5,'alpha',0);
L2 = Link('d',0,'a',2.0,'alpha',0);
L3 = Link('theta',0,'a',0,'alpha',pi/2,'prismatic','qlim',[0 1]);
robot = SerialLink([L1 L2 L3],'name','3R_DrawBot');</div>
            
            <h3>3.2 Cinematica Inversa</h3>
            
            <p>Data una posizione target (x, y) nel piano, √® necessario calcolare gli angoli (Œ∏‚ÇÅ, Œ∏‚ÇÇ) dei giunti. Per un manipolatore 2R planare, la soluzione geometrica √®:</p>
            
            <div class="theory">
                <strong>Algoritmo di cinematica inversa:</strong>
                <ol>
                    <li>Calcolo della distanza dall'origine: 
                        <div class="formula">r = ‚àö(x¬≤ + y¬≤)</div>
                    </li>
                    <li>Verifica raggiungibilit√†: 
                        <div class="formula">|L‚ÇÅ - L‚ÇÇ| ‚â§ r ‚â§ L‚ÇÅ + L‚ÇÇ</div>
                    </li>
                    <li>Calcolo angolo Œ∏‚ÇÇ (legge dei coseni):
                        <div class="formula">
cos(Œ∏‚ÇÇ) = (x¬≤ + y¬≤ - L‚ÇÅ¬≤ - L‚ÇÇ¬≤) / (2L‚ÇÅL‚ÇÇ)
</div>
<div class="formula">
Œ∏‚ÇÇ = atan2(¬±‚àö(1 - cos¬≤(Œ∏‚ÇÇ)), cos(Œ∏‚ÇÇ))
</div>
</li>
<li>Calcolo angolo Œ∏‚ÇÅ:
<div class="formula">
k‚ÇÅ = L‚ÇÅ + L‚ÇÇcos(Œ∏‚ÇÇ), ¬†¬† k‚ÇÇ = L‚ÇÇsin(Œ∏‚ÇÇ)
</div>
<div class="formula">
Œ∏‚ÇÅ = atan2(y, x) - atan2(k‚ÇÇ, k‚ÇÅ)
</div>
</li>
</ol>
</div>
        <p>L'implementazione MATLAB della cinematica inversa √® contenuta nella funzione <code>safeIK2R</code>:</p>
        
        <div class="code-block">function [th1, th2, valid] = safeIK2R(x, y, L1, L2)
r = sqrt(x^2 + y^2);
if r > (L1 + L2) || r < abs(L1-L2)
    th1=0; th2=0; valid=false; 
    return; 
end
cos_th2 = (x^2 + y^2 - L1^2 - L2^2)/(2*L1*L2);
cos_th2 = max(min(cos_th2,1),-1);
sin_th2 = sqrt(max(0,1-cos_th2^2));
th2 = atan2(sin_th2, cos_th2);
k1 = L1 + L2*cos_th2; 
k2 = L2*sin_th2;
th1 = atan2(y,x)-atan2(k2,k1);
valid = true;
end</div>
        <div class="note">
            <strong>Nota sulle soluzioni multiple:</strong> Per un manipolatore 2R planare esistono generalmente due soluzioni ("gomito su" e "gomito gi√π"). Nel codice √® implementata la configurazione "gomito su" (sin_th2 > 0), che garantisce movimenti pi√π fluidi ed evita collisioni con la base.
        </div>
        
        <h3>3.3 Workspace del Robot</h3>
        
        <p>Il workspace del manipolatore 2R √® una <strong>regione anulare</strong> nel piano XY definita da:</p>
        
        <div class="formula">
            r_min = |L‚ÇÅ - L‚ÇÇ| = |2.5 - 2.0| = 0.5
        </div>
        <div class="formula">
            r_max = L‚ÇÅ + L‚ÇÇ = 2.5 + 2.0 = 4.5
        </div>
        
        <p>Questo significa che il robot pu√≤ raggiungere qualsiasi punto nel piano XY la cui distanza dall'origine √® compresa tra 0.5 e 4.5 unit√†.</p>
        
        <table>
            <tr>
                <th>Regione</th>
                <th>Condizione</th>
                <th>Descrizione</th>
            </tr>
            <tr>
                <td>Irraggiungibile (interno)</td>
                <td>r &lt; 0.5</td>
                <td>Troppo vicino alla base</td>
            </tr>
            <tr>
                <td>Raggiungibile</td>
                <td>0.5 ‚â§ r ‚â§ 4.5</td>
                <td>Workspace operativo</td>
            </tr>
            <tr>
                <td>Irraggiungibile (esterno)</td>
                <td>r &gt; 4.5</td>
                <td>Troppo lontano</td>
            </tr>
        </table>
        
        <h4>3.3.1 Posizionamento della Griglia di Gioco</h4>
        
        <p>La griglia 3√ó3 del tris √® posizionata strategicamente all'interno del workspace raggiungibile:</p>
        
        <div class="code-block">cellSize = 0.9;
offset = 0.6;
gridSize = 3 * cellSize = 2.7
% Coordinate griglia
x0 = 0.6, y0 = 0.6
x_max = x0 + gridSize = 3.3
y_max = y0 + gridSize = 3.3</div>
        <p>Tutti i punti della griglia hanno distanza dall'origine compresa nell'intervallo [0.85, 4.67], quindi interamente nel workspace raggiungibile.</p>
        
        <h3>3.4 Cinematica Differenziale e Jacobiano</h3>
        
        <p>Il <strong>Jacobiano</strong> rappresenta la relazione tra velocit√† articolari e velocit√† cartesiane dell'end-effector:</p>
        
        <div class="formula">
            ·∫ã = J(q) ¬∑ qÃá
        </div>
        
        <p>dove ·∫ã = [·∫ã, ·∫è]·µÄ √® la velocit√† cartesiana e qÃá = [Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ]·µÄ √® la velocit√† angolare dei giunti.</p>
        
        <div class="theory">
            <strong>Jacobiano per manipolatore 2R:</strong>
            <p>Derivando le equazioni della cinematica diretta:</p>
	<pre class="formula">
J = ‚é° -L‚ÇÅ sin(Œ∏‚ÇÅ) ‚àí L‚ÇÇ sin(Œ∏‚ÇÅ+Œ∏‚ÇÇ)   -L‚ÇÇ sin(Œ∏‚ÇÅ+Œ∏‚ÇÇ) ‚é§
  ‚é£  L‚ÇÅ cos(Œ∏‚ÇÅ) + L‚ÇÇ cos(Œ∏‚ÇÅ+Œ∏‚ÇÇ)    L‚ÇÇ cos(Œ∏‚ÇÅ+Œ∏‚ÇÇ) ‚é¶
	</pre>
            <p>Le <strong>configurazioni singolari</strong> si verificano quando det(J) = 0, tipicamente quando Œ∏‚ÇÇ = 0 o Œ∏‚ÇÇ = œÄ (braccio completamente esteso o ripiegato).</p>
        </div>
    </div>
</div>

<!-- CAPITOLO 4: COMUNICAZIONE E INTEGRAZIONE -->
<div class="page-break">
    <div class="chapter">
        <h2>4. Comunicazione e Integrazione</h2>
        
        <h3>4.1 Protocollo di Comunicazione Seriale</h3>
        
        <p>La comunicazione tra MATLAB e Arduino avviene tramite porta seriale USB con i seguenti parametri:</p>
        
        <table>
            <tr>
                <th>Parametro</th>
                <th>Valore</th>
            </tr>
            <tr>
                <td>Baud Rate</td>
                <td>115200</td>
            </tr>
            <tr>
                <td>Data Bits</td>
                <td>8</td>
            </tr>
            <tr>
                <td>Stop Bits</td>
                <td>1</td>
            </tr>
            <tr>
                <td>Parity</td>
                <td>None</td>
            </tr>
            <tr>
                <td>Terminatore</td>
                <td>\n (newline)</td>
            </tr>
        </table>
        
        <p>Inizializzazione della porta seriale in MATLAB:</p>
        
        <div class="code-block">function s = initArduino(port)
    % Inizializza la connessione seriale con Arduino
    if nargin < 1, port = "COM4"; end
    disp("üîå Connessione ad Arduino su " + port + " ...");

    try
        s = serialport(port,115200);
        configureTerminator(s,"LF");
        pause(1.0);
        flush(s);
        writeline(s,"A,90,180,90"); % posizione iniziale
        disp("‚úÖ Arduino inizializzato su " + port);
    catch ME
        warning("‚ùå Errore connessione Arduino: " + ME.message);
        s = [];
    end
end</div>
        <h4>4.1.1 Funzione di Invio Comandi</h4>
        
        <p>La funzione <code>sendToArduino</code> gestisce l'invio dei comandi di posizionamento:</p>
        
        <div class="code-block">function sendToArduino(s, th1, th2, z)
    % Invia i comandi di posizione ai servo reali
    % th1, th2 = angoli in radianti
    % z = quota simulata (0.05-0.8) ‚Üí mappata in 180¬∞ (gi√π) ... -90¬∞ (su)

    if isempty(s) || ~isvalid(s)
        warning("‚ö†Ô∏è Arduino non connesso!");
        return;
    end

    % --- Angoli per i servomotori 1 e 2 ---
    a1 = round(90 + rad2deg(th1));  % servo 1 normale

    % Servo 2 invertito: 0 = S, 180 = N
    a2 = round(rad2deg(th2));       % da 0 a 180
    a2 = 180 - a2;                  % inversione

    % --- Servo penna ---
    z_min = 0.05; % penna gi√π
    z_max = 0.8;  % penna su
    servo3 = interp1([z_min z_max], [180 90], z, 'linear', 'extrap'); 

    % --- Clamping ---
    a1 = max(min(a1,180),0);
    a2 = max(min(a2,180),0);
    servo3 = max(min(servo3,190),90);

    % --- Invia comando ad Arduino ---
    cmd = sprintf("A,%d,%d,%d\n", a1, a2, round(servo3));
    writeline(s, cmd);
end
</div>
        <div class="note">
            <strong>Inversione servo 2:</strong> Il secondo servomotore √® montato meccanicamente in modo che 0¬∞ corrisponda a 180¬∞ logici. Per questo motivo viene inviato il valore (180 - Œ∏‚ÇÇ).
        </div>
        
        <h3>4.2 Gestione Interpolazione Hardware</h3>
        
        <p>Arduino implementa un sistema di interpolazione non bloccante per garantire movimenti fluidi tra le configurazioni ricevute.</p>
        
        <h4>4.2.1 Algoritmo di Interpolazione con Easing</h4>
        <div class="code-block">// Funzione di easing in-out per movimento fluido
float easeInOut(float t) {
  // Se t < 0.5 (prima met√†): Accelera con formula 2*t^2
  // Se t >= 0.5 (seconda met√†): Decelera invertendo la parabola
  return t<0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
}</div>
        <div class="theory">
            <strong>Funzione di easing cubico:</strong>
            <p>L'interpolazione utilizza una curva di easing per accelerazione/decelerazione fluida:</p>
            <div class="formula">
                ease(t) = 2t¬≤ &nbsp;&nbsp; se t &lt; 0.5 (Accelerazione)
            </div>
            <div class="formula">
                ease(t) = - 1 + (4t - 2t)t &nbsp;&nbsp; se t ‚â• 0.5 (Decelerazione)
            </div>
            <p>Questo produce movimenti naturali con accelerazione iniziale e decelerazione finale, evitando scatti bruschi.</p>
        </div>
        
        <h4>4.2.2 Parsing dei Comandi</h4>
        
        <div class="code-block">  //Calcolo del tempo trascorso normalizzato tra 0.0 e 1.0
  unsigned long now = millis();
  float t = float(now - moveStartMillis) / moveDuration;
  t = constrain(t, 0.0, 1.0); // Assicura che non si superi il 100%

  // Ottieni il fattore di movimento "curvato" dalla funzione
  float eased = easeInOut(t);

  // Calcola la nuova posizione interpolata
  // Formula: Posizione = Partenza + (DistanzaTotale * FattoreEased)
  cur1 = start1 + (target1 - start1) * eased;
  cur2 = start2 + (target2 - start2) * eased;
  curp = startp + (targetp - startp) * eased;

  // Invia il comando ai servomotori
  s1.write(round(cur1));
  s2.write(round(cur2));
  sp.write(round(curp));</div>
</div>
</div>
<!-- CAPITOLO 5: PIANIFICAZIONE DEL MOTO -->
<div class="page-break">
    <div class="chapter">
        <h2>5. Pianificazione del Moto</h2>
        
        <h3>5.1 Traiettorie Lineari nello Spazio Cartesiano</h3>
        
        <p>Per disegnare linee sul piano, il sistema genera traiettorie lineari nello spazio cartesiano tra due punti, successivamente convertite in comandi articolari tramite cinematica inversa.</p>
        
        <div class="theory">
            <strong>Interpolazione lineare:</strong>
            <p>Data una linea da P‚ÇÅ = (x‚ÇÅ, y‚ÇÅ) a P‚ÇÇ = (x‚ÇÇ, y‚ÇÇ), si generano 40 passi intermedi (waypoint) tramite interpolazione lineare per garantire tratti fluidi.
:</p>
            <div class="formula">
                P·µ¢ = P‚ÇÅ + (P‚ÇÇ - P‚ÇÅ) ¬∑ (i/n) &nbsp;&nbsp; per n = 40
            </div>
            <p>In MATLAB, questo si realizza con la funzione <code>linspace</code>:</p>
        </div>
        
        <div class="code-block">%% --- Funzioni di disegno robot ---
function movePen(robot, ik2R, v, s, x1, y1, z1, x2, y2, z2)
    n=40; xs=linspace(x1,x2,n); ys=linspace(y1,y2,n); zs=linspace(z1,z2,n);
    for i=1:n
        [th1,th2,ok]=ik2R(xs(i),ys(i)); if ~ok, continue; end
        q=[th1 th2 zs(i)];
        sendToArduino(s, q(1), q(2), q(3));
        robot.plot(q,'delay',0.002,'workspace',[-1 5 -1 5 -0.5 1.5]);
        frame=getframe(gca); frame.cdata=imresize(frame.cdata,[525 700]);
        writeVideo(v,frame);
    end
end</div>
        <h3>5.2 Generazione Simboli X e O</h3>
        
        <h4>5.2.1 Simbolo X e O</h4>
        
        <p>Il simbolo X √® decomposto in due segmenti rettilinei diagonali che si intersecano, calcolati rispetto al centro della cella (cx, cy) con un offset diagonale d, mentre il simbolo O √® una traiettoria ad alta definizione composta da 80 punti. I vertici sono generati parametricamente sfruttando seno e coseno rispetto al raggio sdim</p>
        
        <div class="code-block">% Controllo del simbolo da disegnare
    if symbol=='X'
        th=linspace(0,1,40);
        % Prima diagonale
        x1=cx-sdim; y1=cy-sdim; x2=cx+sdim; y2=cy+sdim;
        movePen(robot,ik2R,v,s,cx,cy,z_up,x1,y1,z_down);
        for t=th
            x=x1+(x2-x1)*t; y=y1+(y2-y1)*t;
            [th1,th2,ok]=ik2R(x,y); if ~ok, continue; end
            q=[th1 th2 z_down]; sendToArduino(s,q(1),q(2),q(3));
            robot.plot(q,'delay',0.002); plot3(x,y,0,'r.','MarkerSize',10);
        end
        movePen(robot,ik2R,v,s,x2,y2,z_down,x2,y2,z_up);

        % Seconda diagonale
        x1=cx-sdim; y1=cy+sdim; x2=cx+sdim; y2=cy-sdim;
        movePen(robot,ik2R,v,s,x1,y1,z_up,x1,y1,z_down);
        for t=th
            x=x1+(x2-x1)*t; y=y1+(y2-y1)*t;
            [th1,th2,ok]=ik2R(x,y); if ~ok, continue; end
            q=[th1 th2 z_down]; sendToArduino(s,q(1),q(2),q(3));
            robot.plot(q,'delay',0.002); plot3(x,y,0,'r.','MarkerSize',10);
        end
        movePen(robot,ik2R,v,s,x2,y2,z_down,x2,y2,z_up);
    else
        % Parametro angolare per il cerchio O
        th = linspace(0,2*pi,80);
        x = cx + sdim*cos(th); y = cy + sdim*sin(th); % Coordinate del cerchio
        movePen(robot, ik2R, v, s, cx,cy,z_up,x(1),y(1),z_down);
        for i=1:length(th)     % Disegno del cerchio
            [th1,th2,ok]=ik2R(x(i),y(i)); if ~ok, continue; end
            q=[th1 th2 z_down]; sendToArduino(s,q(1),q(2),q(3));  % Invio dei comandi ad Arduino
            robot.plot(q,'delay',0.002); plot3(x(i),y(i),0,'b.','MarkerSize',10);
        end
        movePen(robot, ik2R, v, s, x(end),y(end),z_down,x(end),y(end),z_up);     % Sollevamento della penna al termine del cerchio
    end
    currPos=[cx,cy,z_up]; % Aggiornamento della posizione corrente della penna</div>
        <div class="highlight">
            <strong>Ottimizzazione tracciato cerchio:</strong>
            <p>Per ridurre il numero di alzate/abbassate della penna, il cerchio viene disegnato come traiettoria continua usando la funzione <code>movePen</code> che gestisce l'interpolazione senza sollevare la penna tra i segmenti.</p>
        </div>
        
        <h3>5.3 Coordinamento Movimenti Penna</h3>
        
        <h4>5.3.1 Funzione movePen Generica</h4>
        
        <p>Questa funzione gestisce il movimento simultaneo di tutti e 3 i giunti tra due configurazioni:</p>
        
        <div class="code-block">function movePen(robot, ik2R, v, s, x1, y1, z1, x2, y2, z2)
    n=40; xs=linspace(x1,x2,n); ys=linspace(y1,y2,n); zs=linspace(z1,z2,n);
    for i=1:n
        [th1,th2,ok]=ik2R(xs(i),ys(i)); if ~ok, continue; end
        q=[th1 th2 zs(i)];
        sendToArduino(s, q(1), q(2), q(3));
        robot.plot(q,'delay',0.002,'workspace',[-1 5 -1 5 -0.5 1.5]);
        frame=getframe(gca); frame.cdata=imresize(frame.cdata,[525 700]);
        writeVideo(v,frame);
    end
end</div>
        <h4>5.3.2 Gestione Stato Persistente</h4>
        
        <p>Per minimizzare i movimenti non necessari, il sistema mantiene traccia della posizione corrente:</p>
        
        <div class="code-block">function drawSymbol(robot, ik2R, v, s, pos, symbol)
    cx=pos(1); cy=pos(2); sdim=0.35; z_up=0.8; z_down=0.05;
    persistent currPos; if isempty(currPos), currPos=[cx cy z_up]; end
    
    % 2. CALCOLO VARIABILE PERSISTENTE
    % "Utilizzando variabili persistent...
    % il robot ricorda la sua ultima posizione"
    movePen(robot, ik2R, v, s, currPos(1),currPos(2),currPos(3),cx,cy,z_up);
    
    % ... (codice che disegna la X e la O) ...

    % 3. AGGIORNAMENTO MEMORIA
    % Salva la posizione finale per il prossimo turno
    currPos=[cx,cy,z_up]; % Aggiornamento della posizione corrente della penna
end</div>
        <div class="note">
            <strong>Ottimizzazione traiettoria:</strong> Mantenere lo stato della posizione corrente riduce significativamente il numero di movimenti "air moves" (movimenti con penna alzata), migliorando l'efficienza temporale del sistema.
        </div>
    </div>
</div>

<!-- CAPITOLO 6: SIMULAZIONE CON ROBOTICS TOOLBOX -->
<div class="page-break">
    <div class="chapter">
        <h2>6. Simulazione con Robotics Toolbox</h2>
        
        <h3>6.1 Modellazione del Robot</h3>
        
        <h4>6.1.1 Definizione Link secondo Denavit-Hartenberg</h4>
        
        <p>La struttura del robot viene definita utilizzando la convenzione DH:</p>
        
        <div class="code-block">% Definizione dei link
L1 = Link('d', 0, 'a', 2.5, 'alpha', 0);
L2 = Link('d', 0, 'a', 2.0, 'alpha', 0);
L3 = Link('theta', 0, 'a', 0, 'alpha', pi/2, ...
'prismatic', 'qlim', [0 1]);
% Creazione catena cinematica
robot = SerialLink([L1 L2 L3], 'name', '3R_DrawBot');</div>
        <div class="theory">
            <strong>Convenzione Denavit-Hartenberg (DH) standard:</strong>
            <p>Ogni link √® caratterizzato da 4 parametri:</p>
            <ul>
                <li><strong>Œ∏·µ¢:</strong> Angolo di rotazione attorno all'asse z·µ¢‚Çã‚ÇÅ</li>
                <li><strong>d·µ¢:</strong> Offset lungo l'asse z·µ¢‚Çã‚ÇÅ</li>
                <li><strong>a·µ¢:</strong> Lunghezza del link lungo x·µ¢</li>
                <li><strong>Œ±·µ¢:</strong> Twist angle tra z·µ¢‚Çã‚ÇÅ e z·µ¢</li>
            </ul>
            <p>La matrice di trasformazione omogenea T·µ¢‚Çã‚ÇÅ‚Å± √® calcolata automaticamente dalla toolbox.</p>
        </div>
        
        <h4>6.1.2 Visualizzazione e Workspace</h4>
        
        <p>La toolbox fornisce metodi per visualizzare il robot nello spazio 3D:</p>
        
        <div class="code-block">workspace = [-1 5 -3 5 -0.5 1.5];
figure('Color', 'w', 'Position', [200 100 900 700]);
axis(workspace);
hold on;
grid on;
axis equal;
view(0, 90);  % Vista dall'alto (piano XY)
xlabel('X'); ylabel('Y');
title('Tris Robotico Interattivo');
% Plot configurazione iniziale
q0 = [0 0 0.8];
robot.plot(q0, 'workspace', workspace, 'delay', 0.01);
drawnow;</div>
        <h3>6.2 Visualizzazione 3D e Registrazione Video</h3>
        
        <h4>6.2.1 Sistema di Registrazione</h4>
        
        <p>Ogni frame della simulazione viene catturato e salvato in un video:</p>
        
        <div class="code-block">% Inizializzazione VideoWriter
v = VideoWriter('tris_robotico_gioco.avi');
v.FrameRate = 25;  % 25 fps per video fluido
open(v);
% Durante la simulazione
for i = 1:n_steps    % con n=40
% Aggiorna robot
robot.plot(q, 'delay', 0.002);
% Cattura frame corrente
frame = getframe(gca);

% Resize per formato standard
frame.cdata = imresize(frame.cdata, [525 700]);

% Scrivi nel video
writeVideo(v, frame);
end
% Chiusura file
close(v);
disp('Video salvato come tris_robotico_gioco.avi');</div>
        <h4>6.2.2 Overlay Grafico Traiettorie</h4>
        
        <p>Le traiettorie disegnate vengono sovrapposte alla visualizzazione del robot:</p>
        
        <div class="code-block">% Durante il disegno di una linea
for i = 1:n
% Aggiorna robot
robot.plot(q, 'delay', 0.002);
% Overlay traccia 2D
plot3(xs(1:i), ys(1:i), zeros(1,i), 'k', 'LineWidth', 2);

% Cattura e salva
frame = getframe(gca);
writeVideo(v, frame);
end</div>
        <div class="note">
            <strong>Visualizzazione dual-mode:</strong> Il sistema mostra contemporaneamente:
            <ul>
                <li>Il modello 3D del robot in movimento (link, giunti)</li>
                <li>Le tracce 2D disegnate sul piano (linee nere/simboli colorati)</li>
            </ul>
            Questo fornisce un feedback visivo completo sull'esecuzione del task.
        </div>
    </div>
</div>

<!-- CAPITOLO 7: LOGICA DI GIOCO E ALGORITMO AI -->
<div class="page-break">
    <div class="chapter">
        <h2>7. Logica di Gioco e Algoritmo AI</h2>
        
        <h3>7.1 Rappresentazione dello Stato</h3>
        
        <p>Lo stato del gioco √® rappresentato tramite una matrice 3√ó3 che codifica il contenuto di ogni cella:</p>
        
        <div class="code-block">% Inizializzazione board
board = repmat(' ', 3, 3);  % Matrice 3x3 di spazi
% Esempio di board durante il gioco:
%     1   2   3
%   +---+---+---+
% 1 | X |   | O |
%   +---+---+---+
% 2 |   | X |   |
%   +---+---+---+
% 3 | O |   |   |
%   +---+---+---+
board =
'X' ' ' 'O'
' ' 'X' ' '
'O' ' ' ' '</div>
        <h4>7.1.1 Mappatura Celle</h4>
        
        <p>Le celle sono numerate da 1 a 9 secondo lo schema:</p>
        
        <div class="code-block">1  2  3
4  5  6
7  8  9</div>
        <p>Le funzioni di conversione tra numero cella e indici matrice sono:</p>
        
        <div class="code-block">function r = cellRow(c)
r = 4 - ceil(c/3);  % Riga: 1‚Üí3, 2‚Üí3, 3‚Üí3, 4‚Üí2, ...
end
function c = cellCol(c)
c = mod(c-1, 3) + 1;  % Colonna: ciclica 1,2,3
end
% Esempio:
% Cella 5 ‚Üí Row=2, Col=2 (centro)
% Cella 1 ‚Üí Row=3, Col=1 (angolo alto-sinistra)</div>
        <h4>7.1.2 Verifica Vincitore</h4>
        
        <p>Il controllo delle condizioni di vittoria verifica 8 possibili linee:</p>
        
        <table>
            <tr>
                <th>Tipo</th>
                <th>Linee</th>
                <th>Celle</th>
            </tr>
            <tr>
                <td>Righe</td>
                <td>3</td>
                <td>[1,2,3], [4,5,6], [7,8,9]</td>
            </tr>
            <tr>
                <td>Colonne</td>
                <td>3</td>
                <td>[1,4,7], [2,5,8], [3,6,9]</td>
            </tr>
            <tr>
                <td>Diagonali</td>
                <td>2</td>
                <td>[1,5,9], [3,5,7]</td>
            </tr>
        </table>
        
        <div class="code-block">function winner = checkWinner(b)
winner = ' ';
lines = [1 2 3; 4 5 6; 7 8 9;   % righe
         1 4 7; 2 5 8; 3 6 9;   % colonne
         1 5 9; 3 5 7];         % diagonali

for i = 1:size(lines, 1)
    l = lines(i, :);
    vals = [b(cellRow(l(1)), cellCol(l(1))), ...
            b(cellRow(l(2)), cellCol(l(2))), ...
            b(cellRow(l(3)), cellCol(l(3)))];
    
    if all(vals == 'X'), winner = 'X'; return; end
    if all(vals == 'O'), winner = 'O'; return; end
end
end</div>
        <h3>7.2 Algoritmo Euristico Minimax</h3>
        
        <p>Il robot implementa un algoritmo di gioco basato su <strong>euristiche minimax</strong> semplificate per garantire prestazioni competitive.</p>
        <h4>7.2.1 Strategia a Tre Livelli</h4>
        
        <p>L'AI del robot segue una gerarchia di priorit√†:</p>
        
        <ol>
            <li><strong>VINCI:</strong> Se esiste una mossa che completa tre in fila, giocala</li>
            <li><strong>BLOCCA:</strong> Se l'avversario pu√≤ vincere alla prossima mossa, blocca</li>
            <li><strong>CENTRO/RANDOM:</strong> Prendi il centro se libero, altrimenti mossa casuale</li>
        </ol>
        
        <div class="theory">
            <strong>Funzione findBestMove:</strong>
            <p>Cerca una cella che completi una linea con 2 simboli uguali e 1 spazio:</p>
            <div class="code-block">function best = findBestMove(board, symbol)
best = 0;
lines = [1 2 3; 4 5 6; 7 8 9; 1 4 7; 2 5 8; 3 6 9; 1 5 9; 3 5 7];

for i = 1:size(lines, 1)
    l = lines(i, :);
    vals = [board(cellRow(l(1)), cellCol(l(1))), ...
            board(cellRow(l(2)), cellCol(l(2))), ...
            board(cellRow(l(3)), cellCol(l(3)))];
    
    % 2 simboli + 1 spazio?
    if sum(vals == symbol) == 2 && sum(vals == ' ') == 1
        idx = find(vals == ' ');
        best = l(idx);
        return;
    end
end
end</div>
</div>
        <h4>7.2.2 Implementazione Decisione Robot</h4>
        
        <div class="code-block">%% --- Ciclo di gioco ---
while winner == ' ' && moves < 9
    if strcmp(turn,'user') %turno utente
    else %turno robot
        free_cells = find(board==' ');
        if isempty(free_cells), break; end

        % --- Robot intelligente ---
        cell_num = findBestMove(board, robot_symbol); % prova a vincere
        if cell_num == -1
            cell_num = findBestMove(board, user_symbol); % blocca utente
            if cell_num == 0
                % centro libero
                if board(2,2) == ' ', cell_num=5; 
                else cell_num=free_cells(randi(length(free_cells))); end
            end
        end
        writeline(s, "MOVE"); % üîä suono cambio turno
        fprintf('ü§ñ Il robot sceglie la cella %d\n',cell_num);
        msg = " E' il mio  turno :)";
        cmd = sprintf("MSG,%s,0,20,2\n", msg);  %s per la stringa
        writeline(s, cmd);
        board(cellRow(cell_num),cellCol(cell_num)) = robot_symbol;
        drawSymbol(robot, ik2R, v, s, centers(cell_num,:), robot_symbol);
        moves = moves + 1;
        winner = checkWinner(board);
        turn = 'user';
    end
end</div>
        <div class="highlight">
            <strong>Efficacia dell'algoritmo:</strong>
            <ul>
                <li>Il robot <strong>non perde mai</strong> contro un avversario che non gioca perfettamente</li>
                <li>Contro gioco perfetto, il risultato √® sempre <strong>pareggio</strong></li>
                <li>Tempo di decisione: <strong>O(1)</strong> ‚Äì costante (max 8 linee da verificare)</li>
                <li>Nessuna ricerca esaustiva dell'albero di gioco richiesta</li>
            </ul>
        </div>
    </div>
</div>

<!-- CAPITOLO 8: TESTING E VALIDAZIONE -->
<div class="page-break">
    <div class="chapter">
        <h2>8. Testing e Validazione</h2>
        
        <h3>8.1 Verifica Cinematica</h3>
        
        <h4>8.1.1 Test Cinematica Diretta vs Inversa</h4>
        
        <p>Per validare l'implementazione cinematica, si verifica la propriet√†:</p>
        
        <div class="formula">
            FK(IK(x, y)) ‚âà (x, y)
        </div>
        
        <p>Procedura di test:</p>
        
        <div class="code-block">% Test su griglia di punti
test_points = [
1.0, 1.0;
2.0, 1.5;
3.0, 2.0;
1.5, 2.5;
2.5, 3.0
];
L1 = 2.5; L2 = 2.0;
errors = [];
for i = 1:size(test_points, 1)
x_target = test_points(i, 1);
y_target = test_points(i, 2);
% Cinematica inversa
[th1, th2, valid] = safeIK2R(x_target, y_target, L1, L2);

if ~valid
    fprintf('Punto (%f, %f) non raggiungibile\n', x_target, y_target);
    continue;
end

% Cinematica diretta
x_calc = L1*cos(th1) + L2*cos(th1+th2);
y_calc = L1*sin(th1) + L2*sin(th1+th2);

% Errore
err = sqrt((x_calc-x_target)^2 + (y_calc-y_target)^2);
errors = [errors; err];

fprintf('Punto (%f, %f) - Errore: %e mm\n', x_target, y_target, err*1000);
end
fprintf('\nErrore medio: %e mm\n', mean(errors)*1000);
fprintf('Errore max: %e mm\n', max(errors)*1000);</div>
        <div class="theory">
            <strong>Risultati test cinematica:</strong>
            <table style="margin-top: 0.5cm;">
                <tr>
                    <th>Metrica</th>
                    <th>Valore</th>
                </tr>
                <tr>
                    <td>Errore medio</td>
                    <td>&lt; 10‚Åª¬π¬≤ unit√† (errore numerico)</td>
                </tr>
                <tr>
                    <td>Errore massimo</td>
                    <td>&lt; 10‚Åª¬π‚Å∞ unit√†</td>
                </tr>
                <tr>
                    <td>Punti testati</td>
                    <td>100% raggiungibili nel workspace</td>
                </tr>
            </table>
            <p>L'implementazione cinematica √® quindi <strong>numericamente accurata</strong>.</p>
        </div>
    </div>
</div>
<!-- CAPITOLO 9: CONCLUSIONI -->
<div class="page-break">
    <div class="chapter">
        <h2>9. Conclusioni</h2>
        
        <h3>9.1 Risultati Ottenuti</h3>
        
        <p>Il progetto ha raggiunto con successo tutti gli obiettivi prefissati, realizzando un sistema robotico completo e funzionante per il gioco del tris. I risultati principali includono:</p>
        
        <div class="highlight">
            <strong>Aspetti teorici implementati:</strong>
            <ul>
                <li><strong>Modellazione cinematica:</strong> Implementazione completa di cinematica diretta e inversa per manipolatore 2R+P secondo convenzione Denavit-Hartenberg</li>
                <li><strong>Analisi workspace:</strong> Caratterizzazione della regione anulare raggiungibile e verifica posizionamento griglia di gioco</li>
                <li><strong>Jacobiano:</strong> Derivazione analitica per analisi velocit√† e identificazione singolarit√†</li>
                <li><strong>Pianificazione moto:</strong> Generazione traiettorie lineari e circolari nello spazio operativo con interpolazione cartesiana</li>
            </ul>
        </div>
        
        <div class="highlight">
            <strong>Aspetti implementativi:</strong>
            <ul>
                <li><strong>Integrazione MATLAB-Arduino:</strong> Protocollo di comunicazione seriale efficiente e robusto</li>
                <li><strong>Controllo tempo reale:</strong> Interpolazione non-bloccante con funzioni di easing per movimenti fluidi</li>
                <li><strong>Algoritmo AI:</strong> Strategia euristica minimax garantisce prestazioni competitive</li>
                <li><strong>Simulazione:</strong> Utilizzo Robotics Toolbox per validazione e generazione video</li>
            </ul>
        </div>
        
        <p>Il sistema √® stato testato con successo attraverso:</p>
        <ul>
            <li>Verifica accuratezza cinematica (errori &lt; 10‚Åª¬π‚Å∞ in simulazione)</li>
            <li>Test ripetibilit√† posizionamento</li>
            <li>Validazione algoritmo AI (100% vittorie/pareggi)</li>
            <li>Registrazione video dell'esecuzione completa</li>
        </ul>
        <div class="note">
            <strong>Considerazioni finali:</strong> Il progetto dimostra come concetti teorici di cinematica, pianificazione del moto e controllo possano essere integrati in un sistema funzionante. L'approccio modulare adottato (separazione cinematica/comunicazione/logica gioco) facilita manutenzione.
        </div>
    </div>
</div>
<!-- APPENDICE A: GUIDA ALL'INSTALLAZIONE -->
    <div class="chapter">
        <h2>Appendice A: Guida all'Installazione e Configurazione</h2>
<h3>Introduzione</h3>
<p>Questa guida ti accompagner√† passo dopo passo nell'installazione e configurazione completa del robot XBOT. Il sistema √® composto da un braccio robotico a 3 gradi di libert√† controllato da Arduino e pilotato da MATLAB tramite comunicazione seriale.<!p>
    <h3>Componenti Hardware Necessari:</h3>
    
    <table>
        <tr>
            <th>Componente</th>
            <th>Consigliato</th>
	    <th>Note</th>
        </tr>
        <tr>
            <td>Scheda Elettronica</td>
            <td>Arduino Uno</td>
            <td>Offre 14 pin digitali (di cui 6 PWM) e 6 ingressi analogici</td>
        </tr>
        <tr>
            <td>3 Servomotori</td>
            <td>Micro servo 9g SG90</td>
            <td>Servo 1, Servo 2, Servo Penna</td>
        </tr>
        <tr>
            <td>Display OLED SSD1306</td>
            <td>128x64 pixel, I2C</td>
            <td>Attensione che alcune misure potrebbero cambiano dipende il modello</td>
        </tr>
        <tr>
            <td>Buzzer</td>
            <td>buzzer attivo</td>
            <td>feedback sonoro</td>
        </tr>
    </table>
    <h3>A.1 Requisiti di Sistema</h3>
    
    <table>
        <tr>
            <th>Componente</th>
            <th>Requisito Minimo</th>
            <th>Requisito Consigliato</th>
        </tr>
        <tr>
            <td>Sistema Operativo</td>
            <td>Windows 10</td>
            <td>Windows 10/11, macOS 12+, Ubuntu 20.04+</td>
        </tr>
        <tr>
            <td>RAM</td>
            <td>4 GB</td>
            <td>8 GB o superiore</td>
        </tr>
        <tr>
            <td>Spazio Disco</td>
            <td>5 GB</td>
            <td>10 GB liberi</td>
        </tr>
        <tr>
            <td>Porta USB</td>
            <td>USB 2.0</td>
            <td>USB 3.0</td>
        </tr>
    </table>
    
    <h3>A.2 Installazione Arduino IDE</h3>
    
    <h4>A.2.1 Download e Installazione</h4>
    
    <p>Scaricare Arduino IDE dal sito ufficiale: <code>https://www.arduino.cc/en/software</code></p>
    
    <ol>
        <li>Selezionare la versione appropriata per il sistema operativo</li>
        <li>Eseguire il file di installazione</li>
        <li>Seguire la procedura guidata accettando le impostazioni predefinite</li>
        <li>Avviare Arduino IDE per verificare l'installazione</li>
    </ol>
    
    <h4>A.2.2 Installazione Librerie Arduino</h4>
    
    <p>Le seguenti librerie sono necessarie per il funzionamento del sistema:</p>
    
    <table>
        <tr>
            <th>Libreria</th>
            <th>Versione</th>
            <th>Procedura Installazione</th>
        </tr>
        <tr>
            <td>Servo</td>
            <td>Standard</td>
            <td>Inclusa di default</td>
        </tr>
        <tr>
            <td>Wire</td>
            <td>Standard</td>
            <td>Inclusa di default</td>
        </tr>
        <tr>
            <td>Adafruit_GFX</td>
            <td>1.x</td>
            <td>Sketch ‚Üí Include Library ‚Üí Manage Libraries ‚Üí Cerca "Adafruit GFX" ‚Üí Install</td>
        </tr>
        <tr>
            <td>Adafruit_SSD1306</td>
            <td>2.x</td>
            <td>Sketch ‚Üí Include Library ‚Üí Manage Libraries ‚Üí Cerca "Adafruit SSD1306" ‚Üí Install</td>
        </tr>
    </table>
    
    <div class="note">
        <strong>Nota:</strong> Durante l'installazione di Adafruit_SSD1306, potrebbero essere richieste dipendenze aggiuntive. Accettare l'installazione di tutte le dipendenze suggerite.
    </div>
    
    <h4>A.2.3 Configurazione Board Arduino</h4>
    
    <div class="code-block">Procedura:

Connettere Arduino al PC tramite cavo USB
Tools ‚Üí Board ‚Üí Selezionare modello (es. "Arduino Uno")
Tools ‚Üí Port ‚Üí Selezionare porta COM assegnata
"Come identificare la porta COM:
‚Ä¢ Windows: Gestione Dispositivi ‚Üí Porte (COM e LPT)
‚Ä¢ macOS: /dev/cu.usbmodem* o /dev/cu.usbserial*
‚Ä¢ Linux: /dev/ttyUSB* o /dev/ttyACM*"
Verificare connessione: File ‚Üí Examples ‚Üí 01.Basics ‚Üí Blink
Upload e verificare LED lampeggiante</div>
 <h3>A.3 Installazione MATLAB R2024b</h3>
 
 <h4>A.3.1 Download MATLAB</h4>
 
 <p>Scaricare MATLAB R2024b dal portale MathWorks: <code>https://it.mathworks.com/downloads/</code></p>
 
 <div class="warning">
     <strong>Licenza Richiesta:</strong> MATLAB richiede una licenza valida. Gli studenti universitari possono verificare la disponibilit√† di licenze accademiche gratuite attraverso il proprio ateneo.
 </div>
 
 <h4>A.3.2 Procedura di Installazione</h4>
 
 <ol>
     <li>Eseguire il file di installazione</li>
     <li>Accedere con le credenziali MathWorks</li>
     <li>Selezionare la licenza da utilizzare</li>
     <li>Nella schermata di selezione prodotti, selezionare almeno MATLAB (base)</li>
     <li>Completare l'installazione (tempo stimato: 30-60 minuti)</li>
 </ol>
 
 <h4>A.3.3 Verifica Installazione</h4>
 
 <div class="code-block">>> ver
MATLAB Version 24.2 (R2024b)
Operating System: ...
Java Version: ...</div>
    <h3>A.4 Installazione Robotics Toolbox</h3>
    
    <h4>A.4.1 Download Toolbox</h4>
    
    <p>Scaricare il Robotics Toolbox di Peter Corke: <code>https://petercorke.com/toolboxes/robotics-toolbox/</code></p>
    <p>Scorri la pagina fino al file richiesto: <strong>RTB10.4.mltbx</strong> (Version 10.4)</p>
    
    <h4>A.4.2 Installazione</h4>
    
    <ol>
        <li>Localizzare il file <code>RTB10.4.mltbx</code> scaricato</li>
        <li>Fare doppio clic sul file .mltbx</li>
        <li>MATLAB si aprir√† automaticamente mostrando la finestra di installazione</li>
        <li>Cliccare su <strong>Install</strong></li>
        <li>Attendere il completamento dell'installazione</li>
        <li>Cliccare su <strong>OK</strong> alla conferma</li>
    </ol>
    
    <div class="note">
        <strong>Nota:</strong> Il toolbox viene installato automaticamente nella cartella Add-Ons di MATLAB e diventa immediatamente disponibile senza necessit√† di configurazioni aggiuntive.
    </div>
    
    <h4>A.4.3 Verifica Installazione Toolbox</h4>
    
    <div class="code-block">% Test 1: Verifica versione
ver
Robotics Toolbox for MATLAB    Version 10.4
% Test 2: Creazione robot di test

L1 = Link('d',0,'a',1,'alpha',0);
robot = SerialLink(L1);
robot.plot([0])</div>


    <div class="highlight">
        <strong>Risultato atteso:</strong> Se compare una finestra 3D con la visualizzazione del robot, l'installazione √® completata correttamente.
    </div>
    
    <h3>A.5 Configurazione File Progetto</h3>
    <p>Scarica i file e i codici del progetto dal repository GitHub: <code>https://github.com/KevinPetrone/XBOT_Progetto_Sistemi_Robotici</code></p>
    <h4>A.5.1 Struttura Directory</h4>
    
    <div class="code-block">XBOT_Project/
‚îú‚îÄ‚îÄ arduino_xbot/
‚îÇ   ‚îî‚îÄ‚îÄ arduino_xbot.ino
‚îî‚îÄ‚îÄ matlab/
‚îú‚îÄ‚îÄ initArduino.m
‚îú‚îÄ‚îÄ sendToArduino.m
‚îî‚îÄ‚îÄ tris_robotics_game_arduino.m</div>
    <h4>A.5.2 Configurazione Porta Seriale</h4>
    
    <p><strong>Identificazione Porta COM:</strong></p>
    
    <table>
        <tr>
            <th>Sistema Operativo</th>
            <th>Procedura</th>
        </tr>
        <tr>
            <td>Windows</td>
            <td>Gestione Dispositivi ‚Üí Porte (COM e LPT) ‚Üí Annotare numero porta (es. COM4)</td>
        </tr>
        <tr>
            <td>macOS</td>
            <td>Terminale: <code>ls /dev/cu.*</code></td>
        </tr>
        <tr>
            <td>Linux</td>
            <td>Terminale: <code>ls /dev/ttyUSB* /dev/ttyACM*</code></td>
        </tr>
    </table>
    
    <p><strong>Modifica file initArduino.m:</strong></p>
    
    <div class="code-block">function s = initArduino(port)
if nargin < 1
    port = "COM4";  % ‚Üê MODIFICARE CON LA PORTA CORRETTA
end

s = serialport(port, 115200);
configureTerminator(s, "LF");
pause(2);
end</div>
    <p><strong>Modifica file tris_robotics_game_arduino.m:</strong></p>
    
    <div class="code-block">% Riga ~6
s = initArduino("COM4");  % ‚Üê MODIFICARE CON LA PORTA CORRETTA</div>
    <h4>A.5.3 Configurazione Current Folder MATLAB</h4>
    
    <div class="warning">
        <strong>FONDAMENTALE:</strong> MATLAB deve avere come Current Folder la directory contenente i file .m prima dell'esecuzione.
    </div>
    
    <div class="code-block">% In MATLAB Command Window:


cd 'C:\XBOT_Project\matlab'
pwd  % Verifica percorso corrente


ans =
'C:\XBOT_Project\matlab'</div>
    <h3>A.6 Caricamento Codice Arduino</h3>
    
    <h4>A.6.1 Verifica Connessioni Hardware</h4>
    
    <table>
        <tr>
            <th>Componente</th>
            <th>Pin Arduino</th>
            <th>Note</th>
        </tr>
        <tr>
            <td>Servo 1 (Base)</td>
            <td>Pin 9</td>
            <td>Segnale PWM</td>
        </tr>
        <tr>
            <td>Servo 2 (Braccio)</td>
            <td>Pin 10</td>
            <td>Segnale PWM</td>
        </tr>
        <tr>
            <td>Servo 3 (Penna)</td>
            <td>Pin 11</td>
            <td>Segnale PWM</td>
        </tr>
        <tr>
            <td>Buzzer</td>
            <td>Pin 3</td>
            <td>Segnale digitale</td>
        </tr>
        <tr>
            <td>OLED SDA</td>
            <td>A4 (Uno)</td>
            <td>Comunicazione I2C</td>
        </tr>
        <tr>
            <td>OLED SCL</td>
            <td>A5 (Uno)</td>
            <td>Comunicazione I2C</td>
        </tr>
        <tr>
            <td>OLED VCC</td>
            <td>5V</td>
            <td>Alimentazione</td>
        </tr>
        <tr>
            <td>OLED GND</td>
            <td>GND</td>
            <td>Massa</td>
        </tr>
    </table>
    
    <h4>A.6.2 Upload Sketch</h4>
    
    <ol>
        <li>Aprire <code>arduino_xbot.ino</code> con Arduino IDE</li>
        <li>Verificare Board e Port corretti</li>
        <li>Cliccare su Verify (‚úì) per compilare</li>
        <li>Se compilazione OK, cliccare su Upload (‚Üí)</li>
        <li>Attendere messaggio "Done uploading"</li>
    </ol>
    
    <div class="highlight">
        <strong>Test Funzionamento:</strong> Dopo l'upload, il display OLED dovrebbe mostrare "XBOT v1.0" e il buzzer dovrebbe riprodurre una melodia di avvio.
    </div>
    
    <h3>A.7 Esecuzione Sistema</h3>
    
    <h4>A.7.1 Checklist Pre-Esecuzione</h4>
    
    <ul>
        <li>‚úì Arduino connesso e programmato</li>
        <li>‚úì MATLAB aperto con Current Folder corretto</li>
        <li>‚úì Porta COM configurata nei file .m</li>
        <li>‚úì Serial Monitor Arduino IDE chiuso</li>
        <li>‚úì Hardware robot assemblato e alimentato</li>
    </ul>
    
    <h4>A.7.2 Avvio Programma</h4>
    
    <div class="code-block">% In MATLAB Command Window:


tris_robotics_game_arduino


üîå Connessione ad Arduino su COM4 ...
‚úÖ Arduino inizializzato su COM4
[Inizializzazione robot e disegno griglia]</div>
    <h3>A.8 Risoluzione Problemi Comuni</h3>
    
    <table>
        <tr>
            <th>Errore</th>
            <th>Causa Probabile</th>
            <th>Soluzione</th>
        </tr>
        <tr>
            <td>Undefined function 'initArduino'</td>
            <td>Current Folder errato</td>
            <td>Verificare con <code>pwd</code> e usare <code>cd</code> per spostarsi</td>
        </tr>
        <tr>
            <td>Cannot connect to port</td>
            <td>Porta COM errata o occupata</td>
            <td>Verificare porta in Gestione Dispositivi, chiudere Serial Monitor</td>
        </tr>
        <tr>
            <td>Display OLED non funziona</td>
            <td>Connessioni I2C o indirizzo errato</td>
            <td>Verificare SDA/SCL, provare indirizzo 0x3D invece di 0x3C</td>
        </tr>
        <tr>
            <td>Undefined function 'SerialLink'</td>
            <td>Robotics Toolbox non installato</td>
            <td>Verificare con <code>ver</code>, reinstallare RTB10.4.mltbx</td>
        </tr>
    </table>
    
    <h3>A.9 Personalizzazione Parametri</h3>
    
    <h4>A.9.1 Lunghezze Bracci Robot</h4>
    
    <div class="code-block">% In tris_robotics_game_arduino.m
L1 = Link('d',0,'a',2.5,'alpha',0);  % Modificare 2.5
L2 = Link('d',0,'a',2.0,'alpha',0);  % Modificare 2.0</div>
    <h4>A.9.2 Velocit√† Movimenti</h4>
    
    <div class="code-block">// In arduino_xbot.ino
const unsigned long moveDuration = 500;  // Modificare valore (ms)</div>
    <h4>A.9.3 Dimensioni Griglia</h4>
    
    <div class="code-block">% In tris_robotics_game_arduino.m
cellSize = 0.9;  % Modificare dimensione celle
offset = 0.6;    % Modificare offset da origine</div>
    <div class="note">
        <strong>Nota:</strong> Dopo ogni modifica dei parametri geometrici, √® necessario verificare che tutte le posizioni rimangano all'interno del workspace raggiungibile del robot.
    </div>
		
	<div style="text-align: center; margin-top: 20px;">
		<img src="./XbOt/try.png" alt="Scansione dell&#39;aula" style="max-width: 90%; height: auto; border: 1px solid #ccc; border-radius: 8px;">
	</div>
</div>
</div>
</body>
</html>
